## 同源之间相互通信

1. Broadcast Channel 可以实现同源不同浏览器窗口之间的通信

```js
// 窗口1
const channel = new BroadCastChannel("my-channel");
channel.postMessage({
  type: "msg",
  data: "hello, world",
});

// 窗口2
// 接收消息 方式1
const channel = new BroadCastChannel("my-channel");
channel.addEventListener("message", e => {
  console.log(e.data); // {type: "msg", data: "hello, world"}
});
// 接收消息 方式2
channel.onmessage = e => {
  console.log(e.data); // {type: "msg", data: "hello, world"}
};
```

2. localStorage 可以实现同源且同同浏览器窗口之间的通信

```js
// 窗口1
window.localStorage.setItem("user", JSON.stringify({ name: "张三", age: 18 }));
window.localStorage.setItem("key", "aaa");

// 窗口2
const user = JSON.parse(window.localStorage.getItem("user")); // {name: "张三", age: 18}
const key = window.localStorage.getItem("key"); // aaa
```

3. sharedWorker 可以实现同源且相同浏览器窗口之间的通信

```js
// shard-worker.js
const ports = []; //保存开启的端口
self.addEventListener("connect", e => {
  const port = e.ports[0];
  ports.push(port);
  port.addEventListener("message", e => {
    ports.forEach(p => {
      if (p !== port) {
        //在不同端口之间广播消息
        p.postMessage(e.data);
      }
    });
  });
});

// 窗口1
const sharedWorker = new ShareWorker("shard-worker.js");
sharedWorker.port.postMessage("hello, world");
sharedWorker.port.onmessage = e => {
  console.log(e.data);
};
sharedWorker.port.start(); //开启端口
```
