## 栈和堆

### 栈（Stack）

- 管理执行上下文：用于存储函数调用、变量、参数等
- 后进先出：最后进入栈的函数最先执行完成
- 自动管理内存：函数执行完成自动清理
- 内存固定：栈内存空间较小，访问速度快

```js
function fn() {
  // 基本类型存储在栈中
  let a = 1;
  let b = "b";
  let c = true;

  // 调用函数创建新的栈帧
  fn1(a);
}

function fn1(a) {
  let d = a + 10; //存储在新的栈帧中
  return d;
}
```

### 调用栈（Call Stack）

每调用一个函数，都会保存其执行上下文，形成一个调用记录，嵌套调用时，会形成调用栈，每次执行完成都清理这个记录。
所以最合理的做法是进行尾调用优化，避免栈内存溢出。

```js
function fn() {
  function fn1() {
    fn2();
  }

  function fn2() {
    fn3();
  }

  function fn3() {}

  fn1();
}

fn();

/**
 * 调用栈演变过程
 * [fn]
 * [fn, fn1]
 * [fn, fn1, fn2]
 * [fn, fn1, fn2, fn3]
 * [fn, fn1, fn2]
 * [fn, fn1]
 * [fn]
 */
```

### 堆（Heap）

- 存储对象和复杂数据结构：对象、数组、函数等
- 动态分配内存：运行时自动分配和释放内存，也可以手动释放
- 内存不固定：堆内存空间较大，访问速度较慢
- 需要垃圾回收：由垃圾回收机制管理内存

```js
// 引用类型存储在堆中, 栈内存则存放引用地址
function fn() {}
let obj = {};
let arr = [1, 2, 3];

let newObj = obj; // 引用复制，指向同一个堆内存对象
```

### 数据存储方式

```js
let a = 100; //栈：直接存储值 100
let b = a; //栈：创建新变量，复制值 100
b = 200; //修改b，不影响a的值
console.log(a); //100
console.log(b); //200

let obj = { name: "Tom" }; //堆：存储对象 {name: "Tom"}, 栈：存储引用地址
let obj2 = obj; //栈：创建新变量，复制引用地址，指向同一个堆内存对象
obj2.name = "Jack"; //修改堆内存对象, obj和obj2的值都改变, 因为指向同一个堆内存对象
console.log(obj.name); //Jack
console.log(obj2.name); //Jack
```
