## 尾调用 和 尾递归

- 尾调用指的是函数的最后一步操作调用了另一个函数。
- 尾递归指的是函数的最后一步操作调用的是自身。

### 尾调用

```js
// 尾调用
function fn() {
  return fn1();
}

// 不是尾调用，因为最后一步操作不是调用另一个函数
function fn2() {
  let res = fn3();
  return res;
}

// 不是尾调用，因为函数调用后还有个加法操作
function fn4() {
  return fn5() + 1;
}

// 是尾调用，尾调用不一定出现在函数内部代码最后一行，只要是最后一步操作即可
function fn6(n) {
  if (n > 0) return fn7(); //return fn7()后，后续就无法执行了，所以是最后一步
  return n;
}
```

每次调用函数，内存中都会保存当前函数的执行上下文，只有执行完毕才会释放，如果函数一层嵌套一层调用就会形成一个调用栈，调用栈越大内存占用越多。而尾调用由于是最后一步操作，所以不需要保存之前的执行上下文，只需要保存内部函数的调用记录即可，这就是尾调用优化。如果每个函数都是尾调用，那么完全可以每次只保留一个调用记录，大大节省内存，直接说尾调用优化的意义。

### 尾递归

- 普通递归会产生大量的调用记录，很容易出现栈溢出
- 尾递归就是对尾调用的一种实现，这样大大节省了内存，防止了栈溢出的风险。

```js
// 普通递归实现阶乘
function fn(n) {
  if (n === 1) return 1;
  return n * fn(n - 1);
}

// 尾递归实现阶乘
function fn1(n, total) {
  if (n === 1) return total;
  return fn1(n - 1, n * total);
}
```

### 尾递归实现斐波那契数列

```js
// 普通递归实现斐波那契数列
function fn(n) {
  if (n <= 1) return n;
  return fn(n - 1) + fn(n - 2);
}

// 尾递归实现斐波那契数列
function fn1(n, a = 0, b = 1) {
  if (n === 0) return a;
  if (n === 1) return b;
  return fn1(n - 1, b, a + b);
}
```
