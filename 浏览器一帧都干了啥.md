## 浏览器一帧都干了啥

通常浏览器的刷新率是 60HZ/s，也就是每 16.6ms 会刷新一次，所以浏览器一帧的时间是 16.6ms, 在这 16.6ms 内浏览器完成了如下操作：

1. 接收输入事件
2. 执行事件回调
3. 开始一帧
4. 执行 RAF（requestAnimationFrame）
5. 页面布局、样式计算
6. 渲染页面
7. 执行 RIC（requestIdleCallback）

**注意：** RIC 并不是每一帧都会执行的，完成了前面的操作还有剩余时间才会执行 RIC，如果时间不够，RIC 会被推迟到下一帧执行。而且 RIC 执行完成后才会进行下一帧，也就是说如果 RIC 执行时间过长，会导致丢帧现象页面卡顿。建议是 30ms 内。

### requestAnimationFrame

window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。

```js
// 不推荐，对比requestAnimationFrame
function animateWithTimeout() {
  element.style.left = `${position}px`;

  if (position < 500) {
    settimeout(animateWithRAF, 1000 / 60); //尝试每秒60帧
  }
}

function animateWithRAF() {
  element.style.left = `${position}px`;

  if (position < 500) {
    requestAnimationFrame(animateWithRAF);
  }
}

requestAnimationFrame(animateWithRAF); //启动

// RAF 优势：
// - 自动匹配显示器刷新率
// - 后台标签页中自动暂停
// - 电池友好
```

### requestIdleCallback

允许在浏览器空闲时间段执行函数回调，从而不影响关键的用户交互和动画渲染，常用于不紧急的后台任务。

```js
function idelCallback(idleDeadline) {
  /**
   * idleDeadline.timeRemaining() 返回当前帧剩余时间
   * idleDeadline.didTimeout 返回是否超时
   */
  if (idleDeadline.timeRemaining() > 0) {
    // 执行任务
  }

  requestIdleCallback(idelCallback);
}

requestIdleCallback(idelCallback); //启动
```

### requestIdleCallback VS requestAnimationFrame

| 特性     | requestIdleCallback                    | requestAnimationFrame          |
| -------- | -------------------------------------- | ------------------------------ |
| 优先级   | 低                                     | 高                             |
| 调用     | 有空闲时调用                           | 浏览器重绘之前                 |
| 调用频率 | 空闲时才调用，频率不固定               | 每一帧调用，通常 16.6ms 一次   |
| 用途     | 非关键的后台任务                       | 动画和交互更新                 |
| 场景     | 预加载、日志上报、数据分析、清理缓存等 | 动画、游戏循环、连续视觉更新等 |
| 取消方式 | cancelIdleCallback(id)                 | cancelAnimationFrame(id)       |
| 兼容性   | 支持较好（Chrome 47+, Firefox 55+）    | 广泛支持， IE10+               |
