## 函数缓存

主要目的是缓存函数的执行结果，利用空间换时间

```js
function memoize(fn, context) {
  const map = new Map()
  context = context || this
  
  return (...args) => {
    let key = JSON.stringify(args)
    // 如果存在缓存，直接返回缓存
    if(map.has(key)) return map.get(key)

    // 不存在则缓存函数结果
    const res = fn.apply(context, args)
    map.set(key, res)
    return res
  }
}

// 使用示例
const add = (x, y) => {
  for(let i = 0; i < 1000000000; i++) {} //模拟耗时操作
  return x + y
}
const calc = memoize(add)
console.time()
const num1 = calc(100, 200)
console.timeEnd() //default: 370.447ms

console.time()
const num2 = calc(100, 200) //读取缓存
console.timeEnd() //default: 0.011ms
```
显而易见遇到复杂操作读取缓存快很多

### 应用场景

- 对于一些函数调用需要执行复杂计算的场景
- 对于有重复输入值的递归函数
- 对于范围有限且输入值高度重复的情况