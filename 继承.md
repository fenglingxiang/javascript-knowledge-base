## 继承

### es5 继承

1. 原型链继承: 通过将一个对象的 **proto** 属性指向另一个对象的 prototype 属性，可以实现继承。

- 优点：实现简单，可继承父类原型上的方法属性
- 缺点：实例对象共享父类引用数据类型属性，一个实例修改其他实例也会改变

```js
function Person(name) {
  this.name = name;
  this.hobby = ["study", "play"];
}

Person.prototype.say = function () {
  console.log("hello");
};

function Child() {}

Child.prototype = new Person("JS");

const child1 = new Child("张三");
child1.hobby.push("eat");
console.log(child1.hobby); //["study", "play", "eat"]
const chuild2 = new Child("李四");
console.log(chuild2.hobby); //["study", "play", "eat"]
child1.say(); //hello
```

2. 借用构造函数继承: 通过复制父类构造函数的属性方法到子类实现继承

- 优点：实例对象不共享父类引用数据类型属性
- 缺点：无法继承父类原型上的方法属性

```js
function Person(name) {
  this.name = name;
  this.hobby = ["study", "play"];
  this.study = () => {
    console.log("study");
  };
}

Person.prototype.say = function () {
  console.log("hello");
};

function Child(name, age) {
  Person.call(this, name);
  this.age = age;
}

const child1 = new Child("张三", 18);
child1.hobby.push("eat");
console.log(child1.hobby); //["study", "play", "eat"]
const chuild2 = new Child("李四", 19);
console.log(chuild2.hobby); //["study", "play"]
child1.study(); //study
child1.say(); //Uncaught TypeError: child1.say is not a function
```

3. 组合继承：结合原型链继承和借用构造函数继承实现

- 优点：结合了原型链继承和借用构造函数继承的优点
- 缺点：调用两次父类构造函数

```js
function Person(name) {
  this.name = name;
  this.hobby = ["study", "play"];
  this.study = () => {
    console.log("study");
  };
}

Person.prototype.say = function () {
  console.log("hello");
};

function Child(name, age) {
  Person.call(this, name);
  this.age = age;
}

Child.prototype = new Person();
Child.prototype.constouctor = Child;

const child1 = new Child("张三", 18);
child1.hobby.push("eat");
console.log(child1.hobby); //["study", "play", "eat"]
const chuild2 = new Child("李四", 19);
console.log(chuild2.hobby); //["study", "play"]
child1.study(); //study
child1.say(); //hello
```

4. 原型式继承：通过 Object.create()方法实现继承

- 优点：不需要调用构造函数
- 缺点：引用数据类型属性共享，无法实现代码复用

```js
const person = {
  hobby: ["study", "play"],
  study: () => {
    console.log("study");
  },
};

const child1 = Object.create(person);
child1.hobby.push("eat");
console.log(child1.hobby); //["study", "play", "eat"]
const child2 = Object.create(person);
console.log(child2.hobby); //["study", "play", "eat"]
child1.study(); //study
```

5. 寄生式继承： 创建一个继承自原型的对象，然后扩展对象，最后返回扩展后的对象

- 优点：对比原型式继承，扩展了对象
- 缺点：引用数据类型属性共享

```js
function createObj(obj) {
  const newObj = Object.create(obj);
  newObj.say = function () {
    console.log("hello");
  };
  return newObj;
}
const person = {
  hobby: ["study", "play"],
  study: () => {
    console.log("study");
  },
};
const child1 = createObj(person);
child1.hobby.push("eat");
console.log(child1.hobby); //["study", "play", "eat"]
const child2 = createObj(person);
console.log(child2.hobby); //["study", "play", "eat"]
child1.say(); //hello
child1.study(); //study
```

6. 寄生组合式继承：结合原型链继承和寄生式的优点， 通过调用父类构造函数继承属性，通过原型链继承方法

- 优点：解决了组合继承的缺点，调用一次父类构造函数
- 缺点：相对比较复杂

```js
function inheritPrototype(child, parent) {
  const prototype = Object.create(parent.prototype); //创建父类原型副本
  prototype.constructor = child; //修正constructor指向
  child.prototype = prototype; //将副本赋值给子类原型
}

function Person(name) {
  this.name = name;
  this.hobby = ["study", "play"];
  this.study = () => {
    console.log("study");
  };
}

Person.prototype.say = function () {
  console.log("hello");
};

function Child(name, age) {
  Person.call(this, name);
  this.age = age;
}

inheritPrototype(Child, Person);

const child1 = new Child("张三", 18);
child1.hobby.push("eat");
console.log(child1.hobby); //["study", "play", "eat"]
const chuild2 = new Child("李四", 19);
console.log(chuild2.hobby); //["study", "play"]
child1.study(); //study
child1.say(); //hello
```

### es6 继承

1. class 类 extends 关键字实现继承

```js
class Man {
  constructor(name) {
    this.name = name;
  }

  static sex = "男";

  static getSex() {
    console.log(this.sex);
  }

  study() {
    console.log("study");
  }
}

class Child extends Man {
  constructor(name, age) {
    super(name);
    this.age = age;
  }

  eat() {
    console.log("eat");
  }

  static getSex() {
    console.log(super.getSex()); //继承静态属性方法
  }
}

const child1 = new Child("张三", 18);
child1.study(); //study
child1.eat(); //eat
Child.getSex(); //男
```
