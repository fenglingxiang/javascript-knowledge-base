## 大文件上传

1. 通过文件唯一标识请求判断文件是否上传过, 上传过直接秒传
2. 判断文件如果完全没上传过，直接走完整切片上传流程
3. 如果文件上传过但是不完整，则查询缺失文件切片序号后走切片上传流程
4. 检查切片完全上传后，请求合并切片得到文件网络路径

- 计算文件唯一标识，借助 spark-md5 计算库

**安装 spark-md5**

```shell
pnpm i spark-md5
```

**或是 cdn 引入**

```html
<script src="https://cdn.jsdelivr.net/npm/spark-md5@3.0.2/spark-md5.min.js"></script>
```

**计算 md5 唯一标识**

```js
/**
 * 计算 md5 唯一标识
 * @param {File} file 要计算的文件
 * @return {Promise<string>} md5 返回唯一标识
 */

// 方案一：小于10MB的文件可通过整个文件计算md5(推荐在小文件使用，不然大文件可能卡死)
const computeMd5 = file => {
  return new Promise((resolve, reject) => {
    try {
      const fileReader = new FileReader();
      const spark = new SparkMD5.ArrayBuffer();

      fileReader.onload = e => {
        spark.append(e.target.result); //append方法将数据添加到hash计算中
        const md5 = spark.end(); //通过end方法获取最终完整的md5值
        resolve(md5);
      };

      fileReader.onerror = () => {
        throw "文件读取失败";
      };

      fileReader.readAsArrayBuffer(file);
    } catch (err) {
      console.log("md5计算失败");
      reject(err);
    }
  });
};

// 方案二：通过文件切片计算md5(推荐大文件使用，防止阻塞ui线程)
const computeMd5 = file => {
  return new Promise((resolve, reject) => {
    try {
      const spark = new SparkMD5.ArrayBuffer();
      const CHUNK_SIZE = 1024 * 1024; //切片大小 1MB
      let curChunk = 0; //当前切片
      const CHUNK_COUNT = Math.ceil(file.size / CHUNK_SIZE);
      const chunkList = []; //文件切片列表

      function loadNext() {
        const start = curChunk * CHUNK_SIZE;
        const end = start + CHUNK_SIZE;
        const blob = file.slice(start, end);
        // 存储文件切片
        chunkList.push({
          index: curChunk,
          blob,
        });
        const fileReader = new FileReader();
        fileReader.readAsArrayBuffer(blob);

        fileReader.onload = e => {
          spark.append(e.target.result);
          // 切片未完成
          if (curChunk < CHUNK_COUNT) {
            curChunk++;
            loadNext(); //继续下一个切片
          } else {
            const md5 = spark.end();
            resolve({
              chunkList,
              md5,
            });
          }
        };
        fileReader.onerror = () => {
          reject("文件读取失败");
        };
      }

      loadNext();
    } catch (err) {
      reject(err);
    }
  });
};
```

- 秒传

```js
// 模拟判断文件是否上传过的api(根据实际情况替换对应api)，如果文件上传过则则直接返回文件网络路径，实现秒传
const mockIsUpload = (file, md5) => {
  return new Promise(resolve => {
    resolve({
      uploadStatus: -1 //上传状态 -1: 完全未上传; 0: 上传过但不完整 1: 已上传
      path: "https://example.com/file/xxx" //文件网络链接
    })
  })
}
```

- 文件切片上传

```js
/**
 * @typedef {Object} Chunk
 * @property {number} index 切片索引
 * @property {Blob} blob 切片数据
 */

/**
 * 单个切片上传
 * @param {Chunk} Chunk 文件切片
 * @param {string} md5 文件唯一标识
 */
const uploadChunk = (chunk, md5) => {
  const formData = new FormData();
  formData.append("blob", chunk.blob);
  formData.append("index", chunk.index);
  formData.append("md5", md5);

  // mockUpload是模拟上传请求(根据实际情况替换真实api)
  return () =>
    mockUpload({
      formData,
    });
};

/**
 * 上传全部切片，控制最大并发，防止请求阻塞
 * @param {Array<Chunk>} chunkList 切片列表
 * @param {string} md5 文件唯一标识
 * @param {Function} onProgress 上传进度回调
 */
const uploadAllChunk = async (chunkList, md5, onProgress) => {
  const taskList = []; //任务列表
  for (let i = 0; i < chunkList.length; i++) {
    taskList.push(uploadChunk(chunkList[i], md5));
  }

  const res = await handlePromisePool(taskList, 5, count =>
    onProgress(count / chunkList.length)
  );
  return res;
};

/**
 * 处理上传任务并发优化
 * @param {Array<() => Promise>} taskList 任务列表
 * @param {number} max 最大并发数
 * @param {Function} onFinishCallback 完成回调
 */
const handlePromisePool = (taskList, max, onFinishCallback) => {
  return new Promise(async (resolve, reject) => {
    const pool = []; //并发池
    const count = 0; //当前已执行任务数
    const res = []; //存储执行结果

    for (let i = 0; i < taskList.length; i++) {
      const task = taskList[i]();
      pool.push(task);

      // 当达到最大并发，优先返回执行最快的完成的结果, 配合await阻塞循环不继续添加任务
      if (pool.length >= max) {
        await Promise.race(pool);
      }

      // 已执行任务处理
      const handler = data => {
        const index = taskList.indexOf(task);
        pool.splice(index, 1);
        res[i] = data;
        count++; //统计已执行任务数
        onFinishCallback && onFinishCallback(count);

        // 全部任务执行完成
        if (count >= taskList.length) {
          resolve(res);
        }
      };

      task
        .then(data => {
          handler(data);
        })
        .catch(err => {
          handler(err);
        });
    }
  });
};
```

- 断点续传，获取文件切片缺失序号，如果存在缺失，则上传缺失切片

```js
// 模拟获取文件缺失切片api(根据实际情况替换对应api)
const mockGetMissChunk = (file, chunkCount, md5) => {
  return new Promise(resolve => {
    resolve([]); //返回缺失文件切片序号数组，为空则文件上传完整
  });
};

/**
 * 检查文件是否上传完整
 * @param {File} file 上传的文件
 * @param {Array<Chunk>} chunkList 切片列表
 * @param {string} md5 文件唯一标识
 * @param {number} maxTest 最大重传次数，超过最大次数则视为上传失败
 */
const isCompleteCheck = async (file, chunkList, md5, maxTest = 5) => {
  const missChunk = await mockGetMissChunk(file, chunkList.length, md5);
  const realUploadedNum = chunkList.length - missChunk.length; //获取实际上传切片数量
  let _maxTest = maxTest;
  onProgress(realUploadedNum / chunkList.length); //更新上传进度

  while (missChunk.length) {
    const taskList = []; //任务列表
    for (let i = 0; i < missChunk.length; i++) {
      taskList.push(uploadChunk(missChunk[i], md5));
    }

    const res = await handlePromisePool(taskList, 5, count => {
      realUploadedNum += count;
      onProgress(realUploadedNum / chunkList.length);
    });

    // 上传完成重新检查是否完整
    const missChunk = await mockGetMissChunk(file, chunkList.length, md5);
    _maxTest--;
    if (!_maxTest) throw `尝试${maxTest}次上传仍上传失败`;
  }
};
```

- 合并切片

```js
// 模拟合并切片api(根据实际情况替换真实api)
const mockMergeChunk = (file, chunkCount, md5) => {
  return new Promise(resolve => reslove("https://examplecom/file/xxx"));
};
```

### 完整上传逻辑

```js
// 分片上传
const uploadFileBySlice = async file => {
  // 计算文件唯一标识，返回标识md5, 切片列表chunkList
  const { chunkList, md5 } = await computeMd5(file);
  const uploadInfo = await mockIsUpload(file, md5);
  /**
   * uploadStatus 上传状态 -1: 完全未上传; 0: 上传过但不完整 1: 已上传
   * path 文件网络路径
   */
  const { uploadStatus, path } = uploadInfo;
  if (uploadStatus === 1 && path) {
    // 上传过直接秒传
    return path;
  } else {
    // 完全未上传
    if (uploadStatus === -1) await uploadAllChunk(chunkList, md5);

    // 检查是否上传完整，不完整则断点续传
    await isCompleteCheck(file, chunkList, md5);

    const path = await mockMergeChunk(file,chunkList.legnth, md5);
    return path;
  }
};
```
